<!DOCTYPE html>
<html>

<head>
    <title>Exploiting Finite State Automata for Efficient Lexical Analysis: A Rust Implementation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

    <script type="module" src="/scripts/main.js" defer></script>
    <link rel="stylesheet" type="text/css" href="/styles/styles.css">
    <link rel="stylesheet" type="text/css" href="/styles/syntax-highlighting.css">


    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>


<body>
    <div id="header-container"></div>

    <main class="main-post">
        <h1>Exploiting Finite State Automata for Efficient Lexical Analysis: A Rust Implementation</h1>

        <h2>Abstract</h2>

        <p>In this post, I will discuss the process of exploiting Finite State Automata (<b>FSA</b>) in particular Non-Deterministic Finite Automata (<b>NFA</b>) for efficient lexical analysis. I will provide a brief introduction to <b>FSA</b> and <b>NFA</b>, and then I will show how to implement a lexical analyzer using <b>NFA</b> in Rust.</p>

        <h2>Introduction</h2>


        <p>I recently had the opportunity to work on a project that required me to implement a <strong>lexical analyzer</strong> for a custom programming language. The language was functional in nature, and the lexical analyzer was required to be as efficient as possible to ensure that the language could be used in real-time applications.</p>

        <p>In my previous experience, I had always used <i>backtracking algorithms</i> to implement lexical analyzers. However, I knew that <i>backtracking algorithms</i> could be inefficient for certain types of languages. So, I decided to explore other options to see if I could find a more efficient solution.</p>

        <h2>Finite State Automata</h2>
        <p>Finite state automata (<strong>FSA</strong>) are commonly used in computer science to model the behavior of systems that can be in one of a finite number of states at any given time. They are used in a wide range of applications, including <i>lexical analysis</i>, <i>parsing</i>, and <i>pattern matching</i>. In literature, there are two main types of finite state automata: deterministic finite automata (<strong>DFA</strong>) and non-deterministic finite automata (<strong>NFA</strong>). NFA is a generalization of DFA, and it can be more expressive than DFA.
        </p>

        <p>
        Theoretically speaking, a finite state automaton is a 5-tuple \((Q, \Sigma, \delta, q_0, F)\), where:
        <!-- <span class="math display"> -->
        \[
            \begin{align*}
                Q      & : \text{a finite non-empty set of states} \\
                \Sigma & : \text{a finite set of input symbols} \\
                \delta & : Q \times \Sigma \rightarrow Q \text{ a transition function} \\
                q_0    \in Q & : \text{the initial state} \\
                F      \subset Q & : \text{a set of final states, possibly empty}
           \end{align*}
        \]
        </p>
        <!-- </span> -->

        <blockquote>
            Note that the transition function \(\delta\) is a partial function, meaning that it is not defined for all possible inputs. In other words, there may be some states in the automaton that do not have transitions for all possible input symbols.
        </blockquote>

        <p>
        <strong>NFA</strong> differs from <strong>DFA</strong> in the transition function \(\delta\), and a state can transition to others without reading a symbol (i.e. \(\epsilon\)-transitions).
        . If the automaton is non-deterministic, then the transition function \(\delta\) is in the form of \(\delta : Q \times \Sigma \rightarrow 2^Q\), where \(2^Q\) is the power set of \(Q\). In other words, the transition function can return a set of states.
        </p>
        <p>
        In this post, I will implement a lexical analyzer using <b>NFA</b> in Rust. I will show how to define the states, transitions, and the lexical rules using <b>NFA</b>.
        </p>

        <h2>FSA vs Backtracking</h2>

        <p>Backtracking algorithms are a common approach to implement lexical analyzers. However, backtracking algorithms can be inefficient for certain types of languages. For example, consider the following regular expression: <code>ab*c</code>. A backtracking algorithm would need to explore all possible paths to match this regular expression, which can be inefficient for long strings. </p>

        <h3>Time Complexity</h3>

        <p>One of the most significant advantages of using <b>FSA</b> over backtracking algorithms is that <b>FSA</b> operates in linear time. This means that the time complexity of an <b>FSA</b>-based lexical analyzer is \(O(n)\), where \(n\) is the length of the input string. In contrast, the time complexity of a backtracking-based lexical analyzer can be exponential in the worst case.</p>

        <h3>Space Complexity</h3>

        <p>Another advantage of using <b>FSA</b> is that it has a lower space complexity compared to backtracking algorithms. <b>FSA</b> uses a fixed amount of memory to store the states and transitions, while backtracking algorithms may need to store multiple paths in memory, which can lead to high space complexity.</p>

        <h3>Error Handling</h3>

        <p>With <b>FSA</b>, error states can be explicitly defined, making it easier to handle unexpected input gracefully. When an FSA encounters an invalid character or sequence, it can transition to an error state and provide informative feedback to the user. In backtracking algorithms, error handling can be more complex and less straightforward, as it might require unwinding multiple levels of recursive calls and tracking the source of the error.</p>

        <h2>Implementation</h2>

        <p>Now that we have discussed the advantages of using <b>FSA</b> for lexical analysis, let's see how we can implement a lexical analyzer using <b>NFA</b> in Rust. In this example, we will implement a simple lexical analyzer that recognizes the following tokens:</p>
        <ul>
            <li>Integer literals (e.g. <code>123</code>)</li>
            <li>Identifiers (e.g. <code>foo</code>)</li>
        </ul>
        <p>For instance, consider the following input string: <code>123 foo</code>. The lexical analyzer should output the following tokens:</p>
        <ul>
            <li>IntegerLiteral(123)</li>
            <li>Identifier(foo)</li>
        </ul>
        <p>
        using the following <b>NFA</b>:
        </p>

        <figure>
            <img src="/posts/static/compilers/exploiting-finite-state-automata-for-efficient-lexical-analysis-a-rust-implementation/automata1.svg"/>
        </figure>

        <h3>The Token Struct</h3>
        <p>We need a struct to represent tokens. The <code>Token</code> struct has two fields: <code>kind</code> to represent the type of the token and <code>lexeme</code> to store the lexeme of the token. The <code>TokenKind</code> enum represents the different types of tokens that the lexer can recognize and it has three variants: <code>Identifier</code>, <code>Number</code>, and <code>EOF</code> (end of file). The <code>Token</code> struct and <code>TokenKind</code> enum are defined as follows:
        </p>


<div style="display: flex; justify-content: center;">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> kind<span class="op">:</span> TokenKind<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> lexeme<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> TokenKind <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    Identifier<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    Number<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cn">EOF</span><span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <h3>The Cursor Struct</h3>

    <p>Next, we need a struct to represent the cursor that will be used to traverse the input string. The <code>Cursor</code> struct has three fields: <code>input</code> to store the input string, <code>position</code> to store the current position in the input string, and <code>offset</code> to store the current offset in the input string. The <code>Cursor</code> struct also has several methods to manipulate the cursor, such as <code>is_eof</code> to check if the cursor has reached the end of the input string, <code>peek</code> to peek at the current character, <code>consume</code> to consume the current character (moving the cursor to the next character incrementing the position and offset), <code>advance</code> to advance the cursor to the next character (incrementing the offset), and <code>align</code> to align the cursor to the current offset. The <code>Cursor</code> struct and its methods are defined as follows:
    </p>

<div style="display: flex; justify-content: center;">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Cursor <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> input<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> position<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> offset<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Cursor <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(input<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> Cursor <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        Cursor <span class="op">{</span> input<span class="op">,</span> position<span class="op">:</span> <span class="dv">0</span><span class="op">,</span> offset<span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> is_eof(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>position <span class="op">&gt;=</span> <span class="kw">self</span><span class="op">.</span>input<span class="op">.</span>len()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> peek(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span> <span class="cf">return</span> <span class="cn">None</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>input<span class="op">.</span>chars()<span class="op">.</span>nth(<span class="kw">self</span><span class="op">.</span>offset)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> consume(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span> <span class="cf">return</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>position <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> advance(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span> <span class="cf">return</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> align(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span> <span class="cf">return</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>position <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>offset<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>


    </main>

    <div id="footer-container"></div>
</body>

</html>
