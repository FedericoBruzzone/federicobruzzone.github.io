<!doctype html>
<html>
    <head>
        <title>
            Exploiting Finite State Automata for Efficient Lexical Analysis: A
            Rust Implementation
        </title>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=yes"
        />

        <script type="module" src="/scripts/main.js" defer></script>
        <link rel="stylesheet" type="text/css" href="/styles/styles.css" />
        <link
            rel="stylesheet"
            type="text/css"
            href="/styles/syntax-highlighting.css"
        />

        <!-- Favicon -->
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="/favicon/apple-touch-icon.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/favicon/favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="/favicon/favicon-16x16.png"
        />
        <link rel="manifest" href="/favicon/site.webmanifest" />
        <meta name="msapplication-TileColor" content="#da532c" />
        <meta name="theme-color" content="#ffffff" />

        <script
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
            type="text/javascript"
        ></script>

        <style>
            pre {
                margin: 1em 0em;
                overflow: auto;
            }

            code {
                font-family: "Fira Mono", monospace;
                font-size: 75%;
                margin: 0;
                hyphens: manual;
            }
        </style>
    </head>

    <body>
        <div id="header-container"></div>

        <main class="main-post">
            <h1>
                Exploiting Finite State Automata for Efficient Lexical Analysis:
                A Rust Implementation
            </h1>

            <h2>Abstract</h2>

            <p>
                In this post, I will discuss the process of exploiting Finite
                State Automata (<b>FSA</b>) in particular Non-Deterministic
                Finite Automata (<b>NFA</b>) for efficient lexical analysis. I
                will provide a brief introduction to <b>FSA</b> and <b>NFA</b>,
                and then I will show how to implement a lexical analyzer using
                <b>NFA</b> in Rust.
            </p>

            <h2>Introduction</h2>

            <p>
                I recently had the opportunity to work on a project that
                required me to implement a <strong>lexical analyzer</strong> for
                a custom programming language. The language was functional in
                nature, and the lexical analyzer was required to be as efficient
                as possible to ensure that the language could be used in
                real-time applications.
            </p>

            <p>
                In my previous experience, I used
                <i>backtracking algorithms</i> to implement lexical analyzers.
                However, I knew that <i>backtracking algorithms</i> could be
                inefficient for certain types of languages. So, I decided to
                explore other options to see if I could find a more efficient
                solution.
            </p>

            <h2>Finite State Automata</h2>
            <p>
                Finite state automata (<strong>FSA</strong>) are commonly used
                in computer science to model the behavior of systems that can be
                in one of a finite number of states at any given time. They are
                used in a wide range of applications, including
                <i>lexical analysis</i>, <i>parsing</i>, and
                <i>pattern matching</i>. In literature, there are two main types
                of finite state automata: deterministic finite automata
                (<strong>DFA</strong>) and non-deterministic finite automata
                (<strong>NFA</strong>). NFA is a generalization of DFA, and it
                can be more expressive than DFA.
            </p>

            <p>
                Theoretically speaking, a finite state automaton is a 5-tuple
                \((Q, \Sigma, \delta, q_0, F)\), where:
                <!-- <span class="math display"> -->
                \[ \begin{align*} Q & : \text{a finite non-empty set of states}
                \\ \Sigma & : \text{a finite set of input symbols} \\ \delta & :
                Q \times \Sigma \rightarrow Q \text{ a transition function} \\
                q_0 \in Q & : \text{the initial state} \\ F \subset Q & :
                \text{a set of final states, possibly empty} \end{align*} \]
            </p>
            <!-- </span> -->

            <blockquote>
                Note that the transition function \(\delta\) is a partial
                function, meaning that it is not defined for all possible
                inputs. In other words, there may be some states in the
                automaton that do not have transitions for all possible input
                symbols.
            </blockquote>

            <p>
                <strong>NFA</strong> differs from <strong>DFA</strong> in the
                transition function \(\delta\), and a state can transition to
                others without reading a symbol (i.e. \(\epsilon\)-transitions).
                . If the automaton is non-deterministic, then the transition
                function \(\delta\) is in the form of \(\delta : Q \times \Sigma
                \rightarrow 2^Q\), where \(2^Q\) is the power set of \(Q\). In
                other words, the transition function can return a set of states.
            </p>
            <p>
                In this post, I will implement a lexical analyzer using
                <b>NFA</b> in Rust. I will show how to define the states,
                transitions, and the lexical rules using <b>NFA</b>.
            </p>

            <h2>FSA</h2>

            <h3>Time Complexity</h3>

            <p>
                One of the most significant advantages of using <b>FSA</b> over
                backtracking algorithms is that <b>FSA</b> operates in linear
                time. This means that the time complexity of an <b>FSA</b>-based
                lexical analyzer is \(O(n)\), where \(n\) is the length of the
                input string. In contrast, the time complexity of a
                backtracking-based lexical analyzer can be exponential in the
                worst case.
            </p>

            <h3>Space Complexity</h3>

            <p>
                Another advantage of using <b>FSA</b> is that it has a lower
                space complexity compared to backtracking algorithms.
                <b>FSA</b> uses a fixed amount of memory to store the states and
                transitions, while backtracking algorithms may need to store
                multiple paths in memory, which can lead to high space
                complexity.
            </p>

            <h3>Error Handling</h3>

            <p>
                With <b>FSA</b>, error states can be explicitly defined, making
                it easier to handle unexpected input gracefully. When an FSA
                encounters an invalid character or sequence, it can transition
                to an error state and provide informative feedback to the user.
                In backtracking algorithms, error handling can be more complex
                and less straightforward, as it might require unwinding multiple
                levels of recursive calls and tracking the source of the error.
            </p>

            <h2>Implementation</h2>

            <p>
                Now that we have discussed the advantages of using
                <b>FSA</b> for lexical analysis, let's see how we can implement
                a lexical analyzer using <b>NFA</b> in Rust. In this example, we
                will implement a simple lexical analyzer that recognizes the
                following tokens:
            </p>
            <ul>
                <li>Integer literals (e.g. <code>123</code>)</li>
                <li>Identifiers (e.g. <code>foo</code>)</li>
            </ul>
            <p>
                For instance, consider the following input string:
                <code>123 foo</code>. The lexical analyzer should output the
                following tokens:
            </p>
            <ul>
                <li>IntegerLiteral(123)</li>
                <li>Identifier(foo)</li>
            </ul>
            <p></p>

            <h3>The Token Struct</h3>
            <p>
                We need a struct to represent tokens. The
                <code>Token</code> struct has two fields: <code>kind</code> to
                represent the type of the token and <code>lexeme</code> to store
                the lexeme of the token. The <code>TokenKind</code> enum
                represents the different types of tokens that the lexer can
                recognize and it has three variants: <code>Identifier</code>,
                <code>Number</code>, and <code>EOF</code> (end of file). The
                <code>Token</code> struct and <code>TokenKind</code> enum are
                defined as follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust numberSource"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> kind<span class="op">:</span> TokenKind<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> lexeme<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> TokenKind <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    Identifier<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    Number<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cn">EOF</span><span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <h3>The Cursor Struct</h3>

            <p>
                Next, we need a struct to represent the cursor that will be used
                to traverse the input string. The <code>Cursor</code> struct has
                three fields: <code>input</code> to store the input string,
                <code>position</code> to store the current position in the input
                string, and <code>offset</code> to store the current offset for
                the current token. The <code>Cursor</code> struct also has
                several methods to manipulate the cursor, such as
                <code>is_eof</code> to check if the cursor has reached the end
                of the input string, <code>peek</code> to peek at the current
                character, <code>advance</code> to advance the cursor to the
                next character (incrementing the offset), and
                <code>align</code> to align the position to the current offset.
                The <code>Cursor</code> struct and its methods are defined as
                follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust numberSource"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Cursor <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> input<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> position<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> offset<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Cursor <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(input<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> Cursor <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        Cursor <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            input<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            position<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            offset<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> is_eof(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">&gt;=</span> <span class="kw">self</span><span class="op">.</span>input<span class="op">.</span>len()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> peek(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>input<span class="op">.</span>chars()<span class="op">.</span>nth(<span class="kw">self</span><span class="op">.</span>offset)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> advance(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> align(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>position <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>offset<span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <h3>State and Transition</h3>

            <p>
                Now, we need to define the <code>State</code> and the
                <code>Transition</code> for the <b>NFA</b>. The
                <code>State</code> trait has a single method
                <code>visit</code> that takes a <code>Cursor</code> and returns
                an <code>Option&lt;Transition&gt;</code>. The
                <code>Transition</code> struct has two fields:
                <code>state</code> to represent the next state and
                <code>transition_kind</code> to represent the kind of
                transition. The <code>TransitionKind</code> enum represents the
                different types of transitions that the <b>NFA</b> can have and
                it has three variants: <code>Advance</code>,
                <code>EmitToken</code>, and <code>End</code>. The
                <code>State</code> trait, <code>Transition</code> struct, and
                <code>TransitionKind</code> enum are defined as follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust numberSource"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> State <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Transition <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> state<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> State<span class="op">&gt;,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> transition_kind<span class="op">:</span> TransitionKind<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> TransitionKind <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    Advance<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    EmitToken(Token)<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    End<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> TransitionKind <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> apply(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>Advance <span class="op">=&gt;</span> cursor<span class="op">.</span>advance()<span class="op">,</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>EmitToken(_) <span class="op">=&gt;</span> cursor<span class="op">.</span>align()<span class="op">,</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>End <span class="op">=&gt;</span> <span class="op">{}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <p>
                Basically, the idea is that when we are in a state, we can visit
                the state with a cursor, and the state will return a transition
                that will tell us what will be the next state (the
                <code>state</code> field) and what we should do (the
                <code>transition_kind</code> field) when we transition from the
                current state to the next state. In the following, we will
                define the states and all will be more clear with some examples.
            </p>

            <h3>The Lexer Struct</h3>

            <p>
                Finally, we need a struct to represent the lexer. The
                <code>Lexer</code> struct has two fields: <code>cursor</code> to
                store the cursor and <code>state</code> to store the current
                state of the lexer. The <code>Lexer</code> struct has two
                methods: <code>new</code> to create a new lexer with the given
                input string and <code>proceed</code> to proceed to the next
                state with the given transition kind. The
                <code>Lexer</code> struct and its methods are defined as
                follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust numberSource"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Lexer <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    cursor<span class="op">:</span> Cursor<span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    state<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> State<span class="op">&gt;,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Lexer <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(input<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> Lexer <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        Lexer <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            cursor<span class="op">:</span> <span class="pp">Cursor::</span>new(input)<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            state<span class="op">:</span> <span class="dt">Box</span><span class="pp">::</span>new(StateStart)<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> proceed(state<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> State<span class="op">&gt;,</span> transition_kind<span class="op">:</span> TransitionKind) <span class="op">-&gt;</span> Transition <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        Transition <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            state<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            transition_kind<span class="op">,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Iterator</span> <span class="cf">for</span> Lexer <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Item <span class="op">=</span> Token<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> transition <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>visit(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span>cursor)<span class="op">?;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">let</span> <span class="pp">TransitionKind::</span>End <span class="op">=</span> transition<span class="op">.</span>transition_kind <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>state <span class="op">=</span> transition<span class="op">.</span>state<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            transition<span class="op">.</span>transition_kind<span class="op">.</span>apply(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span>cursor)<span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">let</span> <span class="pp">TransitionKind::</span>EmitToken(token) <span class="op">=</span> transition<span class="op">.</span>transition_kind <span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="cn">Some</span>(token)<span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <p>
                Usually, a <code>Lexer</code> has a method to get a list of
                tokens from the input string. In this case, we implement the
                <code>Iterator</code> trait for the <code>Lexer</code> struct.
                The <code>next</code> method of the <code>Iterator</code> trait
                is implemented to return the next token in the input string. The
                <code>next</code> method uses a loop to repeatedly visit the
                current state with the cursor and get the transition. If the
                transition kind is <code>End</code>, the
                <code>next</code> method returns <code>None</code> indicating
                that there are no more tokens to emit (stopping the iteration).
                Otherwise, the <code>state</code> field of the
                <code>Lexer</code> struct is updated with the next state and the
                <code>transition_kind</code> field of the transition is applied
                to the cursor. If the transition kind is <code>EmitToken</code>,
                the <code>next</code> method returns the token. Simple, right?
            </p>

            <h3>The States</h3>

            <h4>The Start State</h4>

            <p>
                The <code>StateStart</code> is the initial state of the
                <b>NFA</b>. It is the starting point of the lexical analysis
                process. Trivially, the <code>StateStart</code> struct, being a
                state, implements the <code>State</code> trait and defines the
                <code>visit</code> method. The <code>visit</code> method uses
                the <code>peek</code> method of the <code>Cursor</code> to peek
                at the current character. If the current character is alphabetic
                or an underscore, the <code>visit</code> method returns a
                <code>Transition</code> that transitions to the
                <code>StateWord</code> state advancing the cursor to the next
                character. Analogously, if the current character is numeric, the
                <code>visit</code> method returns a <code>Transition</code> that
                transitions to the <code>StateNumber</code> state advancing the
                cursor to the next character. If the current character is
                neither alphabetic nor numeric, the <code>visit</code> method
                returns a <code>Transition</code> that transitions to the
                <code>StateEOF</code> state. The <code>StateStart</code> struct
                and its implementation are defined as follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust numberSource"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateStart<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateStart <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> cursor<span class="op">.</span>peek() <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_alphabetic() <span class="op">||</span> c<span class="op">.</span>eq(<span class="op">&amp;</span><span class="ch">&#39;_&#39;</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(<span class="dt">Box</span><span class="pp">::</span>new(StateWord)<span class="op">,</span> <span class="pp">TransitionKind::</span>Advance))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_numeric() <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateNumber)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>Advance<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(<span class="dt">Box</span><span class="pp">::</span>new(StateEOF)<span class="op">,</span> <span class="pp">TransitionKind::</span>Advance))<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <blockquote>
                I think that the code is self-explanatory, but note that I am
                not covering the case in which the current character is a
                <i>whitespace</i>. In this case, we should ignore these
                characters and advance the cursor to the next character. In
                fact, if the input string is
                <code> &blank;&blank;&blank;foo 123</code> (starting with
                spaces), the <code>StateStart</code> will go directly to the
                <code>StateEOF</code> state, which is not the expected behavior.
                We should ignore these spaces and go to the
                <code>StateWord</code> state.
                <br />
                I will leave this as an exercise for the reader.
            </blockquote>

            <h4>The Word State</h4>

            <p>
                The <code>StateWord</code> is a state that represents a word
                token. Also, the <code>StateWord</code> struct, being a state,
                implements the <code>State</code> trait and defines the
                <code>visit</code> method. The <code>visit</code> method uses
                the <code>peek</code> method of the <code>Cursor</code> to peek
                at the current character. If the current character is
                alphanumeric or an underscore, the <code>visit</code> method
                returns a <code>Transition</code> that transitions to the
                <code>StateWord</code> state advancing the cursor to the next
                character; basically, the <code>StateWord</code> state is a loop
                that consumes all alphanumeric characters and underscores. If
                the current character is not alphanumeric, the
                <code>visit</code> method returns a <code>Transition</code> that
                transitions to the <code>StateStart</code> state emitting a
                token with the kind <code>Identifier</code> and the lexeme being
                the substring from the cursor position to the cursor offset. The
                <code>StateWord</code> struct and its implementation are defined
                as follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust numberSource"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateWord<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateWord <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> cursor<span class="op">.</span>peek() <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_alphanumeric() <span class="op">||</span> c<span class="op">.</span>eq(<span class="op">&amp;</span><span class="ch">&#39;_&#39;</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(<span class="dt">Box</span><span class="pp">::</span>new(StateWord)<span class="op">,</span> <span class="pp">TransitionKind::</span>Advance))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateStart)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>EmitToken(Token <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                    kind<span class="op">:</span> <span class="pp">TokenKind::</span>Identifier<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                    lexeme<span class="op">:</span> cursor<span class="op">.</span>input[cursor<span class="op">.</span>position<span class="op">..</span>cursor<span class="op">.</span>offset]<span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <h4>The Number State</h4>

            <p>
                The <code>StateNumber</code> is a state that represents a number
                token. The <code>StateNumber</code> struct, being a state,
                implements the <code>State</code> trait and defines the
                <code>visit</code> method. The <code>visit</code> method uses
                the <code>peek</code> method of the <code>Cursor</code> to peek
                at the current character. If the current character is numeric,
                the <code>visit</code> method returns a
                <code>Transition</code> that transitions to the
                <code>StateNumber</code> state advancing the cursor to the next
                character. If the current character is not numeric, the
                <code>visit</code> method returns a <code>Transition</code> that
                transitions to the <code>StateStart</code> state emitting a
                token with the kind <code>Number</code> and the lexeme being the
                substring from the cursor position to the cursor offset. The
                <code>StateNumber</code> struct and its implementation are
                defined as follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateNumber<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateNumber <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> cursor<span class="op">.</span>peek() <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_numeric() <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateNumber)<span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>Advance<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateStart)<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>EmitToken(Token <span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                    kind<span class="op">:</span> <span class="pp">TokenKind::</span>Number<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                    lexeme<span class="op">:</span> cursor<span class="op">.</span>input[cursor<span class="op">.</span>position<span class="op">..</span>cursor<span class="op">.</span>offset]<span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <h4>The EOF State</h4>

            <p>
                I am treating the <code>EOF</code> as a token. The
                <code>StateEOF</code> is a state that represents the end of the
                input string. The <code>StateEOF</code> struct, being a state,
                implements the <code>State</code> trait and defines the
                <code>visit</code> method. The <code>visit</code> method returns
                a <code>Transition</code> that transitions to the
                <code>StateEnd</code> state emitting a token with the kind
                <code>EOF</code> and an empty lexeme. The
                <code>StateEOF</code> struct and its implementation are defined
                as follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust numberSource"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateEOF<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateEOF <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> _cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Box</span><span class="pp">::</span>new(StateEnd)<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>EmitToken(Token <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                kind<span class="op">:</span> <span class="pp">TokenKind::</span><span class="cn">EOF</span><span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                lexeme<span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        ))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <h4>The End State</h4>

            <p>
                The <code>StateEnd</code> is the final state of the <b>NFA</b>.
                It is the ending point of the lexical analysis process.
                Trivially, the <code>StateEnd</code> struct, being a state,
                implements the <code>State</code> trait and defines the
                <code>visit</code> method. The <code>visit</code> method returns
                a <code>Transition</code> that transitions to the
                <code>StateEnd</code> state emitting a token with the kind
                <code>End</code> and an empty lexeme. The
                <code>StateEnd</code> struct and its implementation are defined
                as follows:
            </p>

            <div class="code">
                <div class="sourceCode" id="cb1">
                    <pre
                        class="sourceCode rust"
                    ><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateEnd<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateEnd <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> _cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(Transition <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            state<span class="op">:</span> <span class="dt">Box</span><span class="pp">::</span>new(StateEnd)<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            transition_kind<span class="op">:</span> <span class="pp">TransitionKind::</span>End<span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
                </div>
            </div>

            <h2>Conclusion</h2>

            <p>
                It is important to note that every time we need to emit a token
                we return to <code>StateStart</code>, this is because the start
                state should know all the ways a token can start. So to extend
                while maintaining consistency with this solution, the start
                state should always know where to go unambiguously.
            </p>

            <p>
                A possible question might be:
                <i
                    >how do I distinguish in the practical case an identifier
                    from a keyword?</i
                >
                <br />
                Well, it is trivial. Before emitting a word I can do pattern
                match on the substring to have emit the correct
                <code>TokenKind</code>.
            </p>

            <p>
                I hope you enjoyed this article. If you have any questions or
                suggestions, please
                <a href="https://federicobruzzone.github.io/index.html"
                    >contact me</a
                >.
            </p>
        </main>
        <div id="footer-container"></div>
    </body>
</html>
