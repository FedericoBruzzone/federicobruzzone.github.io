<!DOCTYPE html>
<html>

<head>
    <title>Exploiting Finite State Automata for Efficient Lexical Analysis: A Rust Implementation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

    <script type="module" src="/scripts/main.js" defer></script>
    <link rel="stylesheet" type="text/css" href="/styles/styles.css">
    <link rel="stylesheet" type="text/css" href="/styles/syntax-highlighting.css">


    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

    <style>
    pre {
        margin: 1em 0em;
        overflow: auto;
    }

    code {
        /* font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace; */
        /* font-family: "Iosevka", monospace; */
        font-family: "Fira Mono", monospace;
        font-size: 75%;
        margin: 0;
        hyphens: manual;
    }
    </style>
</head>


<body>
    <div id="header-container"></div>

    <main class="main-post">
        <h1>Exploiting Finite State Automata for Efficient Lexical Analysis: A Rust Implementation</h1>

        <h2>Abstract</h2>

        <p>In this post, I will discuss the process of exploiting Finite State Automata (<b>FSA</b>) in particular Non-Deterministic Finite Automata (<b>NFA</b>) for efficient lexical analysis. I will provide a brief introduction to <b>FSA</b> and <b>NFA</b>, and then I will show how to implement a lexical analyzer using <b>NFA</b> in Rust.</p>

        <h2>Introduction</h2>

        <p>I recently had the opportunity to work on a project that required me to implement a <strong>lexical analyzer</strong> for a custom programming language. The language was functional in nature, and the lexical analyzer was required to be as efficient as possible to ensure that the language could be used in real-time applications.</p>

        <p>In my previous experience, I used <i>backtracking algorithms</i> to implement lexical analyzers. However, I knew that <i>backtracking algorithms</i> could be inefficient for certain types of languages. So, I decided to explore other options to see if I could find a more efficient solution.</p>

        <h2>Finite State Automata</h2>
        <p>Finite state automata (<strong>FSA</strong>) are commonly used in computer science to model the behavior of systems that can be in one of a finite number of states at any given time. They are used in a wide range of applications, including <i>lexical analysis</i>, <i>parsing</i>, and <i>pattern matching</i>. In literature, there are two main types of finite state automata: deterministic finite automata (<strong>DFA</strong>) and non-deterministic finite automata (<strong>NFA</strong>). NFA is a generalization of DFA, and it can be more expressive than DFA.
        </p>

        <p>
        Theoretically speaking, a finite state automaton is a 5-tuple \((Q, \Sigma, \delta, q_0, F)\), where:
        <!-- <span class="math display"> -->
        \[
            \begin{align*}
                Q      & : \text{a finite non-empty set of states} \\
                \Sigma & : \text{a finite set of input symbols} \\
                \delta & : Q \times \Sigma \rightarrow Q \text{ a transition function} \\
                q_0    \in Q & : \text{the initial state} \\
                F      \subset Q & : \text{a set of final states, possibly empty}
           \end{align*}
        \]
        </p>
        <!-- </span> -->

        <blockquote>
            Note that the transition function \(\delta\) is a partial function, meaning that it is not defined for all possible inputs. In other words, there may be some states in the automaton that do not have transitions for all possible input symbols.
        </blockquote>

        <p>
        <strong>NFA</strong> differs from <strong>DFA</strong> in the transition function \(\delta\), and a state can transition to others without reading a symbol (i.e. \(\epsilon\)-transitions).
        . If the automaton is non-deterministic, then the transition function \(\delta\) is in the form of \(\delta : Q \times \Sigma \rightarrow 2^Q\), where \(2^Q\) is the power set of \(Q\). In other words, the transition function can return a set of states.
        </p>
        <p>
        In this post, I will implement a lexical analyzer using <b>NFA</b> in Rust. I will show how to define the states, transitions, and the lexical rules using <b>NFA</b>.
        </p>

        <h2>FSA</h2>

        <h3>Time Complexity</h3>

        <p>One of the most significant advantages of using <b>FSA</b> over backtracking algorithms is that <b>FSA</b> operates in linear time. This means that the time complexity of an <b>FSA</b>-based lexical analyzer is \(O(n)\), where \(n\) is the length of the input string. In contrast, the time complexity of a backtracking-based lexical analyzer can be exponential in the worst case.</p>

        <h3>Space Complexity</h3>

        <p>Another advantage of using <b>FSA</b> is that it has a lower space complexity compared to backtracking algorithms. <b>FSA</b> uses a fixed amount of memory to store the states and transitions, while backtracking algorithms may need to store multiple paths in memory, which can lead to high space complexity.</p>

        <h3>Error Handling</h3>

        <p>With <b>FSA</b>, error states can be explicitly defined, making it easier to handle unexpected input gracefully. When an FSA encounters an invalid character or sequence, it can transition to an error state and provide informative feedback to the user. In backtracking algorithms, error handling can be more complex and less straightforward, as it might require unwinding multiple levels of recursive calls and tracking the source of the error.</p>

        <h2>Implementation</h2>

        <p>Now that we have discussed the advantages of using <b>FSA</b> for lexical analysis, let's see how we can implement a lexical analyzer using <b>NFA</b> in Rust. In this example, we will implement a simple lexical analyzer that recognizes the following tokens:</p>
        <ul>
            <li>Integer literals (e.g. <code>123</code>)</li>
            <li>Identifiers (e.g. <code>foo</code>)</li>
        </ul>
        <p>For instance, consider the following input string: <code>123 foo</code>. The lexical analyzer should output the following tokens:</p>
        <ul>
            <li>IntegerLiteral(123)</li>
            <li>Identifier(foo)</li>
        </ul>
        <p>
        using the following <b>NFA</b>:
        </p>

        <figure>
            <img src="/posts/static/compilers/exploiting-finite-state-automata-for-efficient-lexical-analysis-a-rust-implementation/automata1.svg"/>
        </figure>

        <h3>The Token Struct</h3>
        <p>We need a struct to represent tokens. The <code>Token</code> struct has two fields: <code>kind</code> to represent the type of the token and <code>lexeme</code> to store the lexeme of the token. The <code>TokenKind</code> enum represents the different types of tokens that the lexer can recognize and it has three variants: <code>Identifier</code>, <code>Number</code>, and <code>EOF</code> (end of file). The <code>Token</code> struct and <code>TokenKind</code> enum are defined as follows:
        </p>


<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> kind<span class="op">:</span> TokenKind<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> lexeme<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> TokenKind <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    Identifier<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    Number<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cn">EOF</span><span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <h3>The Cursor Struct</h3>

    <p>Next, we need a struct to represent the cursor that will be used to traverse the input string. The <code>Cursor</code> struct has three fields: <code>input</code> to store the input string, <code>position</code> to store the current position in the input string, and <code>offset</code> to store the current offset for the current token. The <code>Cursor</code> struct also has several methods to manipulate the cursor, such as <code>is_eof</code> to check if the cursor has reached the end of the input string, <code>peek</code> to peek at the current character, <code>advance</code> to advance the cursor to the next character (incrementing the offset), and <code>align</code> to align the position to the current offset. The <code>Cursor</code> struct and its methods are defined as follows:
    </p>

<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Cursor <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> input<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> position<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> offset<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Cursor <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(input<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> Cursor <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        Cursor <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            input<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            position<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            offset<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> is_eof(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">&gt;=</span> <span class="kw">self</span><span class="op">.</span>input<span class="op">.</span>len()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> peek(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>input<span class="op">.</span>chars()<span class="op">.</span>nth(<span class="kw">self</span><span class="op">.</span>offset)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> advance(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> align(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_eof() <span class="op">{</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>position <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>offset<span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>offset <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <h3>State and Transition</h3>

    <p>Now, we need to define the <code>State</code> and the <code>Transition</code> for the <b>NFA</b>. The <code>State</code> trait has a single method <code>visit</code> that takes a <code>Cursor</code> and returns an <code>Option&lt;Transition&gt;</code>. The <code>Transition</code> struct has two fields: <code>state</code> to represent the next state and <code>transition_kind</code> to represent the kind of transition. The <code>TransitionKind</code> enum represents the different types of transitions that the <b>NFA</b> can have and it has three variants: <code>Advance</code>, <code>EmitToken</code>, and <code>End</code>. The <code>State</code> trait, <code>Transition</code> struct, and <code>TransitionKind</code> enum are defined as follows:

<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> State <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Transition <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> state<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> State<span class="op">&gt;,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> transition_kind<span class="op">:</span> TransitionKind<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> TransitionKind <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    Advance<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    EmitToken(Token)<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    End<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> TransitionKind <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> apply(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>Advance <span class="op">=&gt;</span> cursor<span class="op">.</span>advance()<span class="op">,</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>EmitToken(_) <span class="op">=&gt;</span> cursor<span class="op">.</span>align()<span class="op">,</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>End <span class="op">=&gt;</span> <span class="op">{}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <p>Basically, the idea is that when we are in a state, we can visit the state with a cursor, and the state will return a transition that will tell us what will be the next state (the <code>state</code> field) and what we should do (the <code>transition_kind</code> field) when we transition from the current state to the next state. In the following, we will define the states and all will be more clear with some examples.</p>

    <h3>The Lexer Struct</h3>

    <p>Finally, we need a struct to represent the lexer. The <code>Lexer</code> struct has two fields: <code>cursor</code> to store the cursor and <code>state</code> to store the current state of the lexer. The <code>Lexer</code> struct has two methods: <code>new</code> to create a new lexer with the given input string and <code>proceed</code> to proceed to the next state with the given transition kind. The <code>Lexer</code> struct and its methods are defined as follows:

<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Lexer <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    cursor<span class="op">:</span> Cursor<span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    state<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> State<span class="op">&gt;,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Lexer <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(input<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> Lexer <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        Lexer <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            cursor<span class="op">:</span> <span class="pp">Cursor::</span>new(input)<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            state<span class="op">:</span> <span class="dt">Box</span><span class="pp">::</span>new(StateStart)<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> proceed(state<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> State<span class="op">&gt;,</span> transition_kind<span class="op">:</span> TransitionKind) <span class="op">-&gt;</span> Transition <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        Transition <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            state<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            transition_kind<span class="op">,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Iterator</span> <span class="cf">for</span> Lexer <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Item <span class="op">=</span> Token<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> transition <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>visit(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span>cursor)<span class="op">?;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">let</span> <span class="pp">TransitionKind::</span>End <span class="op">=</span> transition<span class="op">.</span>transition_kind <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>state <span class="op">=</span> transition<span class="op">.</span>state<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            transition<span class="op">.</span>transition_kind<span class="op">.</span>apply(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span>cursor)<span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">let</span> <span class="pp">TransitionKind::</span>EmitToken(token) <span class="op">=</span> transition<span class="op">.</span>transition_kind <span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="cn">Some</span>(token)<span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

<p>Usually, a <code>Lexer</code> has a method to get a list of tokens from the input string. In this case, we implement the <code>Iterator</code> trait for the <code>Lexer</code> struct. The <code>next</code> method of the <code>Iterator</code> trait is implemented to return the next token in the input string. The <code>next</code> method uses a loop to repeatedly visit the current state with the cursor and get the transition. If the transition kind is <code>End</code>, the <code>next</code> method returns <code>None</code> indicating that there are no more tokens to emit (stopping the iteration). Otherwise, the <code>state</code> field of the <code>Lexer</code> struct is updated with the next state and the <code>transition_kind</code> field of the transition is applied to the cursor. If the transition kind is <code>EmitToken</code>, the <code>next</code> method returns the token. Simple, right?</p>

    <h3>The States</h3>

    <h4>The Start State</h4>

    <p>The <code>StateStart</code> is the initial state of the <b>NFA</b>. It is the starting point of the lexical analysis process. Trivially, the <code>StateStart</code> struct, being a state, implements the <code>State</code> trait and defines the <code>visit</code> method. The <code>visit</code> method uses the <code>peek</code> method of the <code>Cursor</code> to peek at the current character. If the current character is alphabetic or an underscore, the <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateWord</code> state advancing the cursor to the next character. Analogously, if the current character is numeric, the <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateNumber</code> state advancing the cursor to the next character. If the current character is neither alphabetic nor numeric, the <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateEOF</code> state. The <code>StateStart</code> struct and its implementation are defined as follows:

<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateStart<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateStart <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> cursor<span class="op">.</span>peek() <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_alphabetic() <span class="op">||</span> c<span class="op">.</span>eq(<span class="op">&amp;</span><span class="ch">&#39;_&#39;</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(<span class="dt">Box</span><span class="pp">::</span>new(StateWord)<span class="op">,</span> <span class="pp">TransitionKind::</span>Advance))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_numeric() <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateNumber)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>Advance<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(<span class="dt">Box</span><span class="pp">::</span>new(StateEOF)<span class="op">,</span> <span class="pp">TransitionKind::</span>Advance))<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <blockquote>
        I think that the code is self-explanatory, but note that I am not covering the case in which the current character is a <i>whitespace</i>. In this case, we should ignore these characters and advance the cursor to the next character. In fact, if the input string is <code> &blank;&blank;&blank;foo 123</code> (starting with spaces), the <code>StateStart</code> will go directly to the <code>StateEOF</code> state, which is not the expected behavior. We should ignore these spaces and go to the <code>StateWord</code> state.
        <br>
        I will leave this as an exercise for the reader.
    </blockquote>

    <h4>The Word State</h4>

    <p>The <code>StateWord</code> is a state that represents a word token. Also, the <code>StateWord</code> struct, being a state, implements the <code>State</code> trait and defines the <code>visit</code> method. The <code>visit</code> method uses the <code>peek</code> method of the <code>Cursor</code> to peek at the current character. If the current character is alphanumeric or an underscore, the <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateWord</code> state advancing the cursor to the next character; basically, the <code>StateWord</code> state is a loop that consumes all alphanumeric characters and underscores. If the current character is not alphanumeric, the <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateStart</code> state emitting a token with the kind <code>Identifier</code> and the lexeme being the substring from the cursor position to the cursor offset. The <code>StateWord</code> struct and its implementation are defined as follows:

<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateWord<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateWord <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> cursor<span class="op">.</span>peek() <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_alphanumeric() <span class="op">||</span> c<span class="op">.</span>eq(<span class="op">&amp;</span><span class="ch">&#39;_&#39;</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(<span class="dt">Box</span><span class="pp">::</span>new(StateWord)<span class="op">,</span> <span class="pp">TransitionKind::</span>Advance))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateStart)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>EmitToken(Token <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                    kind<span class="op">:</span> <span class="pp">TokenKind::</span>Identifier<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                    lexeme<span class="op">:</span> cursor<span class="op">.</span>input[cursor<span class="op">.</span>position<span class="op">..</span>cursor<span class="op">.</span>offset]<span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <h4>The Number State</h4>

    <p>The <code>StateNumber</code> is a state that represents a number token. The <code>StateNumber</code> struct, being a state, implements the <code>State</code> trait and defines the <code>visit</code> method. The <code>visit</code> method uses the <code>peek</code> method of the <code>Cursor</code> to peek at the current character. If the current character is numeric, the <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateNumber</code> state advancing the cursor to the next character. If the current character is not numeric, the <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateStart</code> state emitting a token with the kind <code>Number</code> and the lexeme being the substring from the cursor position to the cursor offset. The <code>StateNumber</code> struct and its implementation are defined as follows:


<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateNumber<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateNumber <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> cursor<span class="op">.</span>peek() <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(c) <span class="cf">if</span> c<span class="op">.</span>is_numeric() <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateNumber)<span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>Advance<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Box</span><span class="pp">::</span>new(StateStart)<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                <span class="pp">TransitionKind::</span>EmitToken(Token <span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                    kind<span class="op">:</span> <span class="pp">TokenKind::</span>Number<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                    lexeme<span class="op">:</span> cursor<span class="op">.</span>input[cursor<span class="op">.</span>position<span class="op">..</span>cursor<span class="op">.</span>offset]<span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            ))<span class="op">,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <h4>The EOF State</h4>

    <p>I am treating the <code>EOF</code> as a token. The <code>StateEOF</code> is a state that represents the end of the input string. The <code>StateEOF</code> struct, being a state, implements the <code>State</code> trait and defines the <code>visit</code> method. The <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateEnd</code> state emitting a token with the kind <code>EOF</code> and an empty lexeme. The <code>StateEOF</code> struct and its implementation are defined as follows:

<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust numberSource"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateEOF<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateEOF <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> _cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(<span class="pp">Lexer::</span>proceed(</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Box</span><span class="pp">::</span>new(StateEnd)<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="pp">TransitionKind::</span>EmitToken(Token <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                kind<span class="op">:</span> <span class="pp">TokenKind::</span><span class="cn">EOF</span><span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                lexeme<span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        ))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <h4>The End State</h4>

    <p>The <code>StateEnd</code> is the final state of the <b>NFA</b>. It is the ending point of the lexical analysis process. Trivially, the <code>StateEnd</code> struct, being a state, implements the <code>State</code> trait and defines the <code>visit</code> method. The <code>visit</code> method returns a <code>Transition</code> that transitions to the <code>StateEnd</code> state emitting a token with the kind <code>End</code> and an empty lexeme. The <code>StateEnd</code> struct and its implementation are defined as follows:

<div class="code">
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> StateEnd<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> State <span class="cf">for</span> StateEnd <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> visit(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> _cursor<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Cursor) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Transition<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(Transition <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            state<span class="op">:</span> <span class="dt">Box</span><span class="pp">::</span>new(StateEnd)<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            transition_kind<span class="op">:</span> <span class="pp">TransitionKind::</span>End<span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>

    <h2>Conclusion</h2>

    <p>It is important to note that every time we need to emit a token we return to <code>StateStart</code>, this is because the start state should know all the ways a token can start. So to extend while maintaining consistency with this solution, the start state should always know where to go unambiguously.</p>

    <p> A possible question might be: <i>how do I distinguish in the practical case an identifier from a keyword?</i>
    <br> Well, it is trivial. Before emitting a word I can do pattern match on the substring to have emit the correct <code>TokenKind</code>. </p>

    <p> I hope you enjoyed this article. If you have any questions or suggestions, please <a href="https://federicobruzzone.github.io/index.html">contact me</a>. </p>

    </main>
    <div id="footer-container"></div>
</body>

</html>
