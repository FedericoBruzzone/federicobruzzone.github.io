<!DOCTYPE html>
<html>

<head>
    <title>Pattern Are Just Missing Language Features</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

    <script type="module" src="/scripts/main.js" defer></script>

    <link rel="stylesheet" type="text/css" href="/styles/styles.css">

    <script type="module" src="/scripts/prism.js" defer></script>
    <link rel="stylesheet" type="text/css" href="/styles/prism.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <!-- <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script> -->
</head>


<body>
    <div id="header-container"></div>


    <main class="main-post">
        <h1>Patterns Are Just Missing Language Features</h1>

        <p>
            After investing a lot of time in learning design patterns, I came to the conclusion that most of them are just <i>workarounds for missing language features</i>. That is, if the programming language had certain features, we wouldn't need to use these patterns at all.
            <br>
            <br>
        </p>
        <p>
            In the 90s, mainstream programming languages like C++ and Java lacked many features that are now common in modern languages. For example, they didn't have:
            <ul>
                <li>Higher-order functions (HOFs);</li>
                <li>Closures;</li>
                <li>Algebraic data types (ADTs);</li>
                <li>Pattern matching; and</li>
                <li>First-class modules.<a id="footnote-sum-ref" href="#footnote-sum"><sup>mod</sup></a></li>
            <br>
            <br>
        </p>

        <p>
            In this spite, I decided to write a this post to explain why I think that way (and others previously have too). 
            I will assume that the reader is familiar with the design patterns. If you are not, I recommend reading the book <a href="https://www.amazon.com/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a> by E. Gamma <i>et al.</i> [<a id="cite-dp-ref" href="#cite-dp">1</a>].
        </p>

        <h2>Creational Patterns</h2>
        <p>
            The Abstract Factory pattern is a creational design pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes. It is often used when the system needs to be independent of how its objects are created, composed, and represented.
        <br>
        <br>
        </p>

        <p>I argue that the Abstract Factory pattern is a workaround for the lack of <strong>algebraic data types</strong> (ADTs) + <strong>pattern matching</strong> in mainstream programming languages. Languages like Haskell, OCaml, and Rust have built-in support for ADTs and pattern matching, which makes it easy to create and work with families of related objects without the need for an Abstract Factory.</p>
        <p> An algebraic data type is a composite type that is formed by combining other types. There are two main kinds of algebraic data types: \(\Sigma\)-types (sum types)<a id="footnote-sum-ref" href="#footnote-sum"><sup>sum</sup></a> and \(\Pi\)-types (product types).<a id="footnote-prod-ref" href="#footnote-prod"><sup>prod</sup></a> 
        <br>
        <br>
        </p>
        <p>
        A \(\Sigma\)-type is a type that can take on one of several different forms. For example, in Rust, we can define a sum type using the <code class="language-rust">enum</code> keyword.
        </p>
        <pre class="line-numbers">
        <code class="language-rust">
enum Shape {
    Circle(f64), // radius
    Rectangle(f64, f64), // width, height
    Square(f64), // side length
}
        </code></pre>

        <h2>Structural Patterns</h2>

        <h2>Behavioral Patterns</h2>
        




        <hr>
        <p id="footnote-mod">
        <sup>mod</sup> Java has packages and C++ has namespaces, but they are not first-class citizens. Furthermore, they are solely based on the idea of <i>grouping names</i> and specifying visibility.
        <a href="#footnote-mod-ref">&#8617;</a>
        </p>
        <p id="footnote-sum">
        <sup>sum</sup> Also known as tagged unions or variant types. Examples include enums in Rust, data types in Haskell, and variants in OCaml.
        <a href="#footnote-sum-ref">&#8617;</a>
        </p>
        <p id="footnote-prod">
        <sup>prod</sup> Also known as record types or product types. Examples include structs in C, classes in Java, and tuples in Python. 
        <a href="#footnote-prod-ref">&#8617;</a>
        </p>

        <!-- Horizontal line to separate content -->


        <h2>References</h2>

        <p id="cite-dp">
            [1] Design Patterns: Elements of Reusable Object-Oriented Software, Erich Gamma, Richard Helm, Ralph
            Johnson, John Vlissides, Addison-Wesley Professional, 1995.
            <a href="#cite-dp-ref">&#8617;</a>
        </p>

</body>

</html>
